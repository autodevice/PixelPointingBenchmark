<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Pointing Benchmark Results</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 15px;
            align-items: center;
        }

        .controls-group {
            display: flex;
            gap: 10px;
            align-items: center;
            color: #000
        }

        .controls label {
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        .controls input,         .controls select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            min-width: 200px;
            cursor: pointer;
        }
        
        .controls select:focus {
            outline: none;
            border-color: #667eea;
        }

        .controls button {
            padding: 8px 20px;
            background: #667eea;
            color: rgb(8, 8, 8);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .controls button:hover {
            background: #5568d3;
        }

        .filters {
            padding: 20px 30px;
            background: #f0f0f0;
            border-bottom: 1px solid #e0e0e0;
            display: block;
        }
        
        .filters h4 {
            font-size: 1em;
            margin-bottom: 12px;
            color: #333;
            font-weight: 600;
        }

        .filter-section {
            margin-bottom: 15px;
        }

        .filter-section h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .filter-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
            transition: background 0.2s;
        }

        .filter-checkbox:hover {
            background: #f0f0f0;
        }

        .filter-checkbox input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        .filter-checkbox label {
            cursor: pointer;
            user-select: none;
        }

        .legend {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: none;
        }

        .legend.active {
            display: block;
        }

        .legend h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .legend-item:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .legend-item.hidden {
            opacity: 0.3;
        }

        .legend-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .legend-item.ground-truth .legend-dot {
            width: 16px;
            height: 16px;
            border: 3px solid #000;
            background: white;
        }

        .content {
            padding: 30px;
        }

        .view-toggle {
            padding: 15px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .view-toggle button {
            padding: 8px 16px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .view-toggle button.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .view-toggle button:hover {
            border-color: #667eea;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
        }

        .test-grid.hidden {
            display: none;
        }

        .comparison-table-container {
            display: none;
            padding: 20px 30px;
            overflow-x: auto;
        }

        .comparison-table-container.active {
            display: block;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .comparison-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .comparison-table th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .comparison-table th:first-child {
            position: sticky;
            left: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 10;
        }

        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        .comparison-table tbody tr:hover {
            background: #f8f9fa;
        }

        .comparison-table tbody tr:last-child td {
            border-bottom: none;
        }

        .comparison-table td:first-child {
            position: sticky;
            left: 0;
            background: white;
            z-index: 5;
            font-weight: 500;
        }

        .comparison-table tbody tr:hover td:first-child {
            background: #f8f9fa;
        }

        .model-name-cell {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .model-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .metric-cell {
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .best-metric {
            background: #d4edda;
            font-weight: 600;
        }

        .worst-metric {
            background: #f8d7da;
        }

        .test-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .test-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .test-header {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }

        .test-header h3 {
            color: #333;
            margin-bottom: 5px;
            font-size: 1.2em;
        }

        .test-header p {
            color: #555;
            font-size: 0.95em;
            font-weight: 500;
        }

        .image-container {
            position: relative;
            background: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 205px;
            max-height: 450px;
            overflow: hidden;
        }

        .test-image {
            max-width: 100%;
            max-height: 450px;
            width: auto;
            height: auto;
            display: block;
            object-fit: contain;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .dot {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 3px solid rgba(0, 0, 0, 0.3);
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
            cursor: pointer;
        }

        .dot:hover {
            transform: translate(-50%, -50%) scale(1.3);
            z-index: 10;
        }

        .dot.ground-truth {
            width: 20px;
            height: 20px;
            border: 4px solid #000;
            background: rgba(255, 255, 255, 0.8);
        }

        .test-stats {
            padding: 15px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            font-size: 0.9em;
            min-height: 60px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px 0;
        }

        .stat-row:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: #333;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .stat-value {
            font-weight: 600;
            color: #000;
        }

        .error-message {
            color: #dc3545;
            font-weight: 600;
        }

        .loading, .no-results {
            text-align: center;
            padding: 60px;
            color: #666;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .pass-badge {
            font-size: 0.75em;
            background: #e0e0e0;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¯ Pixel Pointing Benchmark</h1>
            <p>Visualization of VLM Pixel Pointing Accuracy Results</p>
        </div>

        <div class="controls">
            <div class="controls-group">
                <label for="testSuite">Test Suite:</label>
                <select id="testSuite" onchange="loadResults()"></select>
            </div>
        </div>

        <div class="filters" id="filters">
            <div class="filter-section">
                <h4>Show/Hide Models</h4>
                <div class="filter-checkboxes" id="modelFilters"></div>
            </div>
            <div class="filter-section">
                <h4>Show/Hide Passes</h4>
                <div class="filter-checkboxes" id="passFilters"></div>
            </div>
        </div>

        <div class="legend" id="legend" style="display: none;">
        </div>

        <div class="view-toggle" id="viewToggle" style="display: none;">
            <span style="font-weight: 600; margin-right: 10px;">View:</span>
            <button id="gridViewBtn" class="active" onclick="switchView('grid')">Grid View</button>
            <button id="tableViewBtn" onclick="switchView('table')">Table View</button>
        </div>

        <div class="summary-section" id="summarySection" style="display: none; padding: 20px 30px; background: #f8f9fa; border-bottom: 1px solid #e0e0e0;">
            <h3 style="margin-bottom: 15px; color: #333;">Overall Performance Summary</h3>
            <div>
                <h4 style="margin-bottom: 10px; color: #555;">Accuracy Table</h4>
                <table id="accuracyTable" style="width: 100%; border-collapse: collapse; background: white; border-radius: 6px; overflow: hidden;">
                    <thead>
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 10px; text-align: left;">Model</th>
                            <th style="padding: 10px; text-align: right;">Within 5px</th>
                            <th style="padding: 10px; text-align: right;">Within 10px</th>
                        </tr>
                    </thead>
                    <tbody id="accuracyTableBody">
                    </tbody>
                </table>
            </div>
        </div>

            <div class="content" id="content">
            <div class="loading">Select a test suite to begin</div>
        </div>

        <div class="comparison-table-container" id="comparisonTableContainer">
            <table class="comparison-table" id="comparisonTable">
                <thead id="comparisonTableHead">
                    <tr>
                        <th>Test Case</th>
                    </tr>
                </thead>
                <tbody id="comparisonTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const MODEL_COLORS = {
            'sonnet': 'rgb(168, 2, 15)',
            'opus': 'rgb(255, 132, 0)',
            'gemini3': 'rgb(0, 255, 76)',
            'chatgpt': 'rgb(17, 160, 207)',
            'haiku': 'rgb(164, 11, 224)',
            'grok-4.1': 'rgb(255, 20, 147)',
            'qwen3-vl': 'rgb(34, 139, 34)',
            'glm-4.6v': 'rgb(255, 165, 0)',
            'gemini-2.5-flash': 'rgb(30, 144, 255)',
        };

        const MODEL_PRICING = {
            'sonnet': 3.00,
            'opus': 5.00,
            'gemini3': 2.00,
            'chatgpt': 1.75,
            'haiku': 1.00,
            'grok-4.1': 1.00,
            'qwen3-vl': 0.20,
            'glm-4.6v': 0.30,
        };

        let currentData = null;
        let currentTestSuite = null;
        let availableTestSuites = [];
        let visibleModels = new Set();
        let visiblePasses = new Set();
        let currentView = 'grid';

        function getModelColor(modelName) {
            return MODEL_COLORS[modelName.toLowerCase()] || '#6C757D';
        }

        function loadResults() {
            const dir = 'results';
            const testSuite = document.getElementById('testSuite').value;
            
            if (!testSuite) {
                return;
            }

            const content = document.getElementById('content');
            content.innerHTML = '<div class="loading">Loading results</div>';

            if (testSuite === '__resolution_test__') {
                fetch(`${dir}/test_suites.json`)
                    .then(response => {
                        if (!response.ok) throw new Error('test_suites.json not found');
                        return response.json();
                    })
                    .then(testSuitesData => {
                        const allSuites = testSuitesData.test_suites || [];
                        const sweepSuites = allSuites.filter(s => s.startsWith('resolution_test_'));
                        
                        if (sweepSuites.length === 0) {
                            content.innerHTML = '<div class="no-results">No resolution_test_* suites found in this results directory.</div>';
                            return;
                        }

                        return Promise.all(
                            sweepSuites.map(suiteName =>
                                fetch(`${dir}/${suiteName}/custom/consolidated_results.json`)
                                    .then(r => {
                                        if (!r.ok) throw new Error(`Failed to load results for ${suiteName}`);
                                        return r.json();
                                    })
                                    .then(d => ({ suiteName, data: d }))
                            )
                        );
                    })
                    .then(items => {
                        if (!items) return;
                        
                        const merged = {
                            test_suite: '__resolution_test__',
                            screen_size: { name: 'mixed', width: null, height: null },
                            models: {},
                            tests: []
                        };

                        items.forEach(({ suiteName, data }) => {
                            if (data && data.models) {
                                Object.keys(data.models).forEach(m => {
                                    merged.models[m] = data.models[m];
                                });
                            }

                            const screenSize = data && data.screen_size ? data.screen_size : null;
                            (data.tests || []).forEach(t => {
                                merged.tests.push({
                                    ...t,
                                    test_name: `${suiteName} / ${t.test_name}`,
                                    prompt: `[${suiteName}] ${t.prompt || ''}`.trim(),
                                    _suiteName: suiteName,
                                    _screenSize: screenSize
                                });
                            });
                        });

                        if (!merged.tests || merged.tests.length === 0) {
                            throw new Error('No test results found in resolution test suites');
                        }

                        currentData = merged;
                        currentTestSuite = '__resolution_test__';
                        visibleModels.clear();
                        visiblePasses.clear();
                        updateFilters(merged);
                        updateViewToggle();
                        displayResults(merged, dir, '__resolution_test__');
                        updateComparisonTable(merged);
                        updateSummaryTables(merged);
                    })
                    .catch(error => {
                        content.innerHTML = `<div class="no-results">Error: ${error.message}</div>`;
                        console.error('Error loading resolution sweep:', error);
                    });

                return;
            }

            fetch(`${dir}/${testSuite}/custom/consolidated_results.json`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to load results for ${testSuite}. Make sure the test suite exists in the results directory.`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data.tests || data.tests.length === 0) {
                        throw new Error('No test results found in this test suite');
                    }
                    currentData = data;
                    currentTestSuite = testSuite;
                    visibleModels.clear();
                    visiblePasses.clear();
                    updateFilters(data);
                    updateViewToggle();
                    displayResults(data, dir, testSuite);
                    updateComparisonTable(data);
                    updateSummaryTables(data);
                })
                .catch(error => {
                    content.innerHTML = `<div class="no-results">Error: ${error.message}<br><br>Available test suites are listed in the dropdown above.</div>`;
                    console.error('Error loading results:', error);
                });
        }

        function updateFilters(data) {
            const modelFilters = document.getElementById('modelFilters');
            const passFilters = document.getElementById('passFilters');
            const filtersDiv = document.getElementById('filters');
            
            modelFilters.innerHTML = '';
            passFilters.innerHTML = '';
            
            const allModels = new Set();
            const allPasses = new Set();
            
            data.tests.forEach(test => {
                Object.keys(test.models || {}).forEach(model => {
                    allModels.add(model);
                    const modelData = test.models[model];
                    if (modelData && modelData.predictions) {
                        modelData.predictions.forEach(pred => {
                            if (pred.pass_number) {
                                allPasses.add(pred.pass_number);
                            }
                        });
                    }
                });
            });
            
            if (allModels.size === 0 && data.models) {
                Object.keys(data.models).forEach(model => allModels.add(model));
            }
            
            Array.from(allModels).sort().forEach(model => {
                const checkbox = document.createElement('div');
                checkbox.className = 'filter-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox" id="model-${model}" checked onchange="toggleModel('${model}')">
                    <label for="model-${model}" style="cursor: pointer;">${model}</label>
                `;
                modelFilters.appendChild(checkbox);
                visibleModels.add(model);
            });
            
            Array.from(allPasses).sort().forEach(passNum => {
                const checkbox = document.createElement('div');
                checkbox.className = 'filter-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox" id="pass-${passNum}" checked onchange="togglePass(${passNum})">
                    <label for="pass-${passNum}" style="cursor: pointer;">Pass ${passNum}</label>
                `;
                passFilters.appendChild(checkbox);
                visiblePasses.add(passNum);
            });
            
            if (allModels.size > 0 || allPasses.size > 0) {
                filtersDiv.classList.add('active');
            } else {
                filtersDiv.classList.remove('active');
            }
        }

        function toggleModel(model) {
            const checkbox = document.getElementById(`model-${model}`);
            if (checkbox.checked) {
                visibleModels.add(model);
            } else {
                visibleModels.delete(model);
            }
            if (currentData) {
                displayResults(currentData, 'results', currentTestSuite);
                updateComparisonTable(currentData);
            }
        }

        function togglePass(passNum) {
            const checkbox = document.getElementById(`pass-${passNum}`);
            if (checkbox.checked) {
                visiblePasses.add(passNum);
            } else {
                visiblePasses.delete(passNum);
            }
            if (currentData) {
                displayResults(currentData, 'results', currentTestSuite);
                updateComparisonTable(currentData);
            }
        }

        function updateLegend(models) {
            const legend = document.getElementById('legend');
            const legendItems = document.getElementById('legendItems');
            legendItems.innerHTML = '';


            const modelsToShow = models ? Object.keys(models) : Array.from(visibleModels);
            
            modelsToShow.forEach(modelName => {
                const isVisible = visibleModels.has(modelName);
                const item = document.createElement('div');
                item.className = `legend-item ${isVisible ? '' : 'hidden'}`;
                item.style.cursor = 'pointer';
                item.onclick = () => {
                    const checkbox = document.getElementById(`model-${modelName}`);
                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                        toggleModel(modelName);
                    }
                };
                const color = getModelColor(modelName);
                item.innerHTML = `
                    <div class="legend-dot" style="background-color: ${color};"></div>
                    <span>${modelName}</span>
                `;
                legendItems.appendChild(item);
            });

            if (modelsToShow.length > 0) {
                legend.classList.add('active');
            }
        }

        function switchView(view) {
            currentView = view;
            const gridBtn = document.getElementById('gridViewBtn');
            const tableBtn = document.getElementById('tableViewBtn');
            const content = document.getElementById('content');
            const tableContainer = document.getElementById('comparisonTableContainer');
            
            if (view === 'grid') {
                gridBtn.classList.add('active');
                tableBtn.classList.remove('active');
                content.style.display = 'block';
                tableContainer.classList.remove('active');
            } else {
                gridBtn.classList.remove('active');
                tableBtn.classList.add('active');
                content.style.display = 'none';
                tableContainer.classList.add('active');
            }
        }

        function updateViewToggle() {
            const viewToggle = document.getElementById('viewToggle');
            if (currentData && currentData.tests && currentData.tests.length > 0) {
                viewToggle.style.display = 'flex';
            } else {
                viewToggle.style.display = 'none';
            }
        }

        function displayResults(data, baseDir, testSuite) {
            const content = document.getElementById('content');
            
            if (!data.tests || data.tests.length === 0) {
                content.innerHTML = '<div class="no-results">No test results found</div>';
                return;
            }

            const grid = document.createElement('div');
            grid.className = 'test-grid';

            data.tests.forEach(test => {
                const screenSize = test._screenSize || data.screen_size;
                const card = createTestCard(test, baseDir, testSuite, screenSize);
                grid.appendChild(card);
            });

            content.innerHTML = '';
            content.appendChild(grid);
        }

        function updateComparisonTable(data) {
            if (!data.tests || data.tests.length === 0) return;
            
            const tableBody = document.getElementById('comparisonTableBody');
            const tableHead = document.getElementById('comparisonTableHead');
            tableBody.innerHTML = '';
            
            const allModels = Array.from(Object.keys(data.models || {})).sort();
            const visibleModelsList = Array.from(visibleModels).filter(m => allModels.includes(m)).sort();
            
            if (visibleModelsList.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="2" style="text-align: center; padding: 40px;">No models selected</td></tr>';
                tableHead.innerHTML = '<tr><th>Test Case</th></tr>';
                return;
            }
            
            tableHead.innerHTML = '';
            const headerRow = document.createElement('tr');
            
            const testHeader = document.createElement('th');
            testHeader.textContent = 'Test Case';
            testHeader.style.width = '200px';
            headerRow.appendChild(testHeader);
            
            visibleModelsList.forEach(model => {
                const th = document.createElement('th');
                th.innerHTML = `<div class="model-name-cell"><span class="model-dot" style="background-color: ${getModelColor(model)};"></span>${model}</div>`;
                headerRow.appendChild(th);
            });
            
            tableHead.appendChild(headerRow);
            
            const modelMetrics = {};
            visibleModelsList.forEach(model => {
                modelMetrics[model] = {
                    distances: [],
                    errors: 0,
                    total: 0
                };
            });
            
            data.tests.forEach(test => {
                const row = document.createElement('tr');
                
                const testCell = document.createElement('td');
                testCell.innerHTML = `<strong>${test.test_name}</strong><br><small style="color: #666;">${test.prompt}</small>`;
                row.appendChild(testCell);
                
                visibleModelsList.forEach(model => {
                    const cell = document.createElement('td');
                    cell.className = 'metric-cell';
                    
                    const modelData = test.models?.[model];
                    if (!modelData || !modelData.predictions) {
                        cell.textContent = 'N/A';
                        cell.style.color = '#999';
                    } else {
                        const predictions = modelData.predictions || [];
                        const visiblePredictions = predictions.filter(p => 
                            !p.pass_number || visiblePasses.has(p.pass_number)
                        );
                        
                        if (visiblePredictions.length === 0) {
                            cell.textContent = 'No data';
                            cell.style.color = '#999';
                        } else {
                            const distances = visiblePredictions
                                .map(p => p.distance)
                                .filter(d => d !== null && d !== undefined);
                            
                            if (distances.length > 0) {
                                const avgDist = distances.reduce((a, b) => a + b, 0) / distances.length;
                                const stdDev = distances.length > 1 
                                    ? Math.sqrt(distances.reduce((sum, d) => sum + Math.pow(d - avgDist, 2), 0) / distances.length)
                                    : 0;
                                
                                cell.textContent = `${avgDist.toFixed(2)}px`;
                                if (distances.length > 1) {
                                    cell.innerHTML = `${avgDist.toFixed(2)}px<br><small style="color: #666;">Ïƒ=${stdDev.toFixed(2)}</small>`;
                                }
                                
                                modelMetrics[model].distances.push(avgDist);
                                modelMetrics[model].total++;
                            } else if (visiblePredictions.some(p => p.error)) {
                                cell.textContent = 'Error';
                                cell.style.color = '#dc3545';
                                modelMetrics[model].errors++;
                                modelMetrics[model].total++;
                            } else {
                                cell.textContent = 'N/A';
                                cell.style.color = '#999';
                            }
                        }
                    }
                    
                    row.appendChild(cell);
                });
                
                tableBody.appendChild(row);
            });
            
            const summaryRow = document.createElement('tr');
            summaryRow.style.background = '#f8f9fa';
            summaryRow.style.fontWeight = '600';
            
            const summaryLabel = document.createElement('td');
            summaryLabel.textContent = 'Average';
            summaryRow.appendChild(summaryLabel);
            
            const modelAverages = {};
            visibleModelsList.forEach(model => {
                const metrics = modelMetrics[model];
                if (metrics.distances.length > 0) {
                    modelAverages[model] = metrics.distances.reduce((a, b) => a + b, 0) / metrics.distances.length;
                }
            });
            
            // Include 0 as a valid average (0 is falsy in JS but should be displayed/highlighted).
            const validAverages = Object.values(modelAverages).filter(v => v !== null && v !== undefined && !Number.isNaN(v));
            const bestAvg = validAverages.length > 0 ? Math.min(...validAverages) : null;
            const worstAvg = validAverages.length > 0 ? Math.max(...validAverages) : null;
            
            visibleModelsList.forEach(model => {
                const cell = document.createElement('td');
                cell.className = 'metric-cell';
                
                if (modelAverages[model] !== undefined && modelAverages[model] !== null && !Number.isNaN(modelAverages[model])) {
                    cell.textContent = `${modelAverages[model].toFixed(2)}px`;
                    if (bestAvg !== null && modelAverages[model] === bestAvg) {
                        cell.classList.add('best-metric');
                    } else if (worstAvg !== null && bestAvg !== worstAvg && modelAverages[model] === worstAvg) {
                        cell.classList.add('worst-metric');
                    }
                } else {
                    cell.textContent = 'N/A';
                    cell.style.color = '#999';
                }
                summaryRow.appendChild(cell);
            });
            
            tableBody.appendChild(summaryRow);
        }

        function updateSummaryTables(data) {
            const summarySection = document.getElementById('summarySection');
            const accuracyTableBody = document.getElementById('accuracyTableBody');
            
            if (!data || !data.tests || data.tests.length === 0) {
                summarySection.style.display = 'none';
                return;
            }
            
            summarySection.style.display = 'block';
            accuracyTableBody.innerHTML = '';
            
            const modelStats = {};
            const visibleModelsList = Array.from(visibleModels);

            const hasPassesInData = data.tests.some(test =>
                Object.keys(test.models || {}).some(modelName => {
                    const modelResult = test.models[modelName];
                    const predictions = (modelResult && modelResult.predictions) ? modelResult.predictions : [];
                    return predictions.some(p => p.pass_number);
                })
            );
            const hasVisiblePasses = visiblePasses.size > 0;

            if (hasPassesInData && !hasVisiblePasses) {
                summarySection.style.display = 'none';
                return;
            }

            data.tests.forEach(test => {
                visibleModelsList.forEach(modelName => {
                    const modelData = (test.models || {})[modelName];
                    if (!modelData) return;

                    if (!modelStats[modelName]) {
                        modelStats[modelName] = {
                            avgDistancesByTest: [],
                            totalTests: 0,
                            numNoPredictionOrError: 0
                        };
                    }

                    const predictions = Array.isArray(modelData.predictions) ? modelData.predictions : [];

                    const selectedPredictions = predictions.filter(pred => {
                        if (pred.pass_number) return visiblePasses.has(pred.pass_number);
                        return !hasPassesInData;
                    });

                    const distances = selectedPredictions
                        .map(pred => pred.distance)
                        .filter(d => d !== null && d !== undefined && !Number.isNaN(d));

                    modelStats[modelName].totalTests++;

                    if (distances.length === 0) {
                        modelStats[modelName].numNoPredictionOrError++;
                        modelStats[modelName].avgDistancesByTest.push(null);
                        return;
                    }

                    const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
                    modelStats[modelName].avgDistancesByTest.push(avgDistance);
                });
            });

            const modelAccuracies = {};
            Object.keys(modelStats).forEach(modelName => {
                const stats = modelStats[modelName];
                const validAvgDistances = stats.avgDistancesByTest.filter(d => d !== null && d !== undefined);
                if (stats.totalTests > 0) {
                    const within5 = validAvgDistances.filter(d => d <= 5).length;
                    const within10 = validAvgDistances.filter(d => d <= 10).length;
                    const accuracy5px = (within5 / stats.totalTests) * 100;
                    const accuracy10px = (within10 / stats.totalTests) * 100;
                    modelAccuracies[modelName] = {
                        accuracy5px,
                        accuracy10px,
                        passed5: within5,
                        passed10: within10,
                        totalTests: stats.totalTests
                    };
                }
            });
            
            const sortedModels = Object.keys(modelAccuracies).sort((a, b) => 
                modelAccuracies[b].accuracy10px - modelAccuracies[a].accuracy10px
            );
            
            sortedModels.forEach(modelName => {
                const acc = modelAccuracies[modelName];
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #e0e0e0';
                
                const modelCell = document.createElement('td');
                modelCell.style.padding = '10px';
                modelCell.innerHTML = `<span class="model-dot" style="background-color: ${getModelColor(modelName)}; display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px;"></span>${modelName}`;
                row.appendChild(modelCell);
                
                const acc5pxCell = document.createElement('td');
                acc5pxCell.style.padding = '10px';
                acc5pxCell.style.textAlign = 'right';
                acc5pxCell.textContent = `${acc.accuracy5px.toFixed(1)}%`;
                acc5pxCell.title = `${acc.passed5}/${acc.totalTests} tests within 5px (avg across selected passes per test)`;
                row.appendChild(acc5pxCell);
                
                const acc10pxCell = document.createElement('td');
                acc10pxCell.style.padding = '10px';
                acc10pxCell.style.textAlign = 'right';
                acc10pxCell.textContent = `${acc.accuracy10px.toFixed(1)}%`;
                acc10pxCell.title = `${acc.passed10}/${acc.totalTests} tests within 10px (avg across selected passes per test)`;
                if (acc.accuracy10px >= 90) {
                    acc10pxCell.style.color = '#28a745';
                    acc10pxCell.style.fontWeight = '600';
                } else if (acc.accuracy10px >= 70) {
                    acc10pxCell.style.color = '#ffc107';
                }
                row.appendChild(acc10pxCell);
                
                accuracyTableBody.appendChild(row);
            });
        }

        function createTestCard(test, baseDir, testSuite, screenSize) {
            const card = document.createElement('div');
            card.className = 'test-card';

            const header = document.createElement('div');
            header.className = 'test-header';
            header.innerHTML = `
                <h3>${test.test_name}</h3>
                <p>${test.prompt}</p>
            `;

            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';
            
            const img = document.createElement('img');
            img.className = 'test-image';
            const suiteForImage = test._suiteName || testSuite;
            img.src = `${baseDir}/${suiteForImage}/custom/${test.image_file}`;
            img.alt = test.test_name;
            img.onload = function() {
                drawOverlay(imageContainer, test, screenSize, img);
            };

            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            overlay.id = `overlay-${test.test_name}`;
            
            imageContainer.appendChild(img);
            imageContainer.appendChild(overlay);

            const stats = document.createElement('div');
            stats.className = 'test-stats';
            
            const statsHTML = [];
            const hasVisibleModels = Array.from(Object.keys(test.models || {})).some(m => visibleModels.has(m));
            const hasVisiblePasses = visiblePasses.size > 0;
            const hasPassesInData = Array.from(Object.keys(test.models || {})).some(modelName => {
                const modelResult = test.models[modelName];
                const predictions = modelResult.predictions || [];
                return predictions.some(p => p.pass_number);
            });
            
            if (!hasVisibleModels) {
                statsHTML.push('<div class="stat-row"><span class="stat-label" style="flex-direction: column; align-items: flex-start;"><span>No models selected. Use filters above to show models.</span></span></div>');
            } else if (hasPassesInData && !hasVisiblePasses) {
                statsHTML.push('<div class="stat-row"><span class="stat-label" style="flex-direction: column; align-items: flex-start;"><span>No passes selected. Use filters above to show passes.</span></span></div>');
            } else {
                Object.keys(test.models || {}).forEach(modelName => {
                    if (!visibleModels.has(modelName)) return;
                    
                    const modelResult = test.models[modelName];
                    const predictions = modelResult.predictions || [];
                    
                    const visiblePredictions = predictions.filter(p => 
                        !p.pass_number || visiblePasses.has(p.pass_number)
                    );
                    
                    if (visiblePredictions.length === 0) {
                        return;
                    }
                    
                    const distances = visiblePredictions
                        .map(p => p.distance)
                        .filter(d => d !== null && d !== undefined);
                    
                    if (distances.length > 0) {
                        const avgDist = distances.reduce((a, b) => a + b, 0) / distances.length;
                        const minDist = Math.min(...distances);
                        const maxDist = Math.max(...distances);
                        const stdDev = distances.length > 1 
                            ? Math.sqrt(distances.reduce((sum, d) => sum + Math.pow(d - avgDist, 2), 0) / distances.length)
                            : 0;
                        
                        const color = getModelColor(modelName);
                        statsHTML.push(`
                            <div class="stat-row">
                                <span class="stat-label">
                                    <span class="stat-label-dot" style="background-color: ${color};"></span>
                                    <strong>${modelName}:</strong>
                                </span>
                                <span class="stat-value">
                                    ${avgDist.toFixed(2)}px avg
                                    ${distances.length > 1 ? ` (Ïƒ=${stdDev.toFixed(2)})` : ''}
                                    ${minDist !== maxDist ? ` [${minDist.toFixed(1)}-${maxDist.toFixed(1)}]` : ''}
                                </span>
                            </div>
                        `);
                    } else if (visiblePredictions.some(p => p.error)) {
                        const color = getModelColor(modelName);
                        statsHTML.push(`
                            <div class="stat-row">
                                <span class="stat-label">
                                    <span class="stat-label-dot" style="background-color: ${color};"></span>
                                    <strong>${modelName}:</strong>
                                </span>
                                <span class="stat-value error-message">Error</span>
                            </div>
                        `);
                    } else {
                        const color = getModelColor(modelName);
                        statsHTML.push(`
                            <div class="stat-row">
                                <span class="stat-label">
                                    <span class="stat-label-dot" style="background-color: ${color};"></span>
                                    <strong>${modelName}:</strong>
                                </span>
                                <span class="stat-value">No prediction</span>
                            </div>
                        `);
                    }
                });
            }
            
            stats.innerHTML = statsHTML.join('') || '<div class="stat-row"><span class="stat-label">No results available</span></div>';

            card.appendChild(header);
            card.appendChild(imageContainer);
            card.appendChild(stats);

            return card;
        }

        function drawOverlay(container, test, screenSize, img) {
            const overlay = container.querySelector('.overlay');
            
            const displayWidth = img.offsetWidth;
            const displayHeight = img.offsetHeight;
            
            overlay.style.width = `${displayWidth}px`;
            overlay.style.height = `${displayHeight}px`;

            const scaleX = displayWidth / screenSize.width;
            const scaleY = displayHeight / screenSize.height;

            overlay.innerHTML = '';

            const hasVisiblePasses = visiblePasses.size > 0;
            const hasPassesInData = Array.from(Object.keys(test.models || {})).some(modelName => {
                const modelResult = test.models[modelName];
                const predictions = modelResult.predictions || [];
                return predictions.some(p => p.pass_number);
            });
            
            const hasAnyVisiblePredictions = Array.from(Object.keys(test.models || {})).some(modelName => {
                if (!visibleModels.has(modelName)) return false;
                const modelResult = test.models[modelName];
                const predictions = modelResult.predictions || [];
                return predictions.some(pred => {
                    if (pred.predicted_coords && !pred.error) {
                        if (pred.pass_number) {
                            return visiblePasses.has(pred.pass_number);
                        }
                        return !hasPassesInData || hasVisiblePasses === false;
                    }
                    return false;
                });
            });

            if (hasPassesInData && !hasVisiblePasses) {
                return;
            }

            if (!hasAnyVisiblePredictions) {
                return;
            }

            Object.keys(test.models || {}).forEach(modelName => {
                if (!visibleModels.has(modelName)) return;
                
                const modelResult = test.models[modelName];
                const predictions = modelResult.predictions || [];
                
                predictions.forEach((pred, idx) => {
                    if (pred.predicted_coords && !pred.error) {
                        if (pred.pass_number && !visiblePasses.has(pred.pass_number)) return;
                        if (!pred.pass_number && hasPassesInData && hasVisiblePasses) return;
                        
                        const [predX, predY] = pred.predicted_coords;
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        const color = getModelColor(modelName);
                        dot.style.backgroundColor = color;
                        dot.style.left = `${predX * scaleX}px`;
                        dot.style.top = `${predY * scaleY}px`;
                        
                        const opacity = predictions.length > 1 ? 0.7 : 1.0;
                        dot.style.opacity = opacity;
                        
                        const distance = pred.distance !== null ? pred.distance.toFixed(2) : 'N/A';
                        const passInfo = pred.pass_number ? ` (Pass ${pred.pass_number})` : '';
                        dot.title = `${modelName}${passInfo}: (${predX}, ${predY}) - Distance: ${distance}px`;
                        overlay.appendChild(dot);
                    }
                });
            });
        }

        function loadTestSuites() {
            const dir = 'results';
            
            fetch(`${dir}/test_suites.json`)
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    }
                    throw new Error('test_suites.json not found');
                })
                .then(data => {
                    const select = document.getElementById('testSuite');
                    select.innerHTML = '<option value="">Select test suite...</option>';
                    if (data.test_suites && data.test_suites.length > 0) {
                        const allResolutionSuites = data.test_suites.filter(s => s.startsWith('resolution_test_'));
                        const filteredSuites = data.test_suites.filter(s => !s.startsWith('resolution_test_'));
                        availableTestSuites = filteredSuites.slice();

                        if (allResolutionSuites.length >= 1) {
                            const opt = document.createElement('option');
                            opt.value = '__resolution_test__';
                            opt.textContent = `resolution_test`;
                            select.appendChild(opt);
                        }

                        filteredSuites.forEach(suite => {
                            const option = document.createElement('option');
                            option.value = suite;
                            option.textContent = suite;
                            select.appendChild(option);
                        });
                    } else {
                        select.innerHTML = '<option value="">No test suites found</option>';
                    }
                })
                .catch(() => {
                    fetch(`${dir}/`)
                        .then(response => response.text())
                        .then(html => {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(html, 'text/html');
                            const links = Array.from(doc.querySelectorAll('a'))
                                .map(a => a.textContent.trim().replace('/', ''))
                                .filter(name => name && name !== '..' && name !== '.');
                            
                            const allResolutionSuites = links.filter(s => s.startsWith('resolution_test_'));
                            const filteredLinks = links.filter(s => !s.startsWith('resolution_test_'));
                            
                            const select = document.getElementById('testSuite');
                            select.innerHTML = '<option value="">Select test suite...</option>';
                            
                            if (allResolutionSuites.length >= 1) {
                                const opt = document.createElement('option');
                                opt.value = '__resolution_test__';
                                opt.textContent = `resolution_test`;
                                select.appendChild(opt);
                            }
                            
                            if (filteredLinks.length > 0) {
                                filteredLinks.forEach(suite => {
                                    const option = document.createElement('option');
                                    option.value = suite;
                                    option.textContent = suite;
                                    select.appendChild(option);
                                });
                            } else {
                                select.innerHTML = '<option value="basic_shapes">basic_shapes (default)</option>';
                            }
                        })
                        .catch(() => {
                            const select = document.getElementById('testSuite');
                            select.innerHTML = '<option value="basic_shapes">basic_shapes (default)</option>';
                        });
                });
        }

        window.onload = function() {
            loadTestSuites();
        };
    </script>
</body>
</html>

